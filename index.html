<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터베이스 중간 예제 풀이</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>데이터베이스 중간 예제 풀이</h1>
            <nav>
                <ul>
                    <li><a href="#problem1">문제 1: 모델 변환</a></li>
                    <li><a href="#problem2">문제 2: 관계대수</a></li>
                    <li><a href="#problem3">문제 3: SQL</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <div class="container">
            <section id="intro" class="card">
                <h2>데이터베이스 중간고사 문제 분석 및 정답 검토 보고서</h2>
                <p>제출된 데이터베이스 중간고사 문제는 데이터베이스 설계, 관계대수, SQL 등 핵심 개념을 다루는 3개의 문제로 구성되어 있습니다. 각 문제의 풀이를 상세히 분석하고 정답 여부를 검토한 결과, 모든 문제가 정답으로 판정되었으며, 데이터베이스의 주요 개념들이 정확하게 이해되고 적용되었음을 확인했습니다.</p>
            </section>

            <section id="problem1" class="card">
                <h2>문제 1: 데이터베이스 모델 변환: 비정규화 vs 정규화 모델 비교</h2>
                <div class="image-container">
                    <img src="images/quiz1.png" alt="문제 1 이미지">
                </div>
                <p>은행의 고객-계좌 데이터를 저장하는 모델을 비정규화된 단일 테이블과 정규화된 3개 테이블로 각각 변환하는 문제입니다.</p>
                
                <div class="grid-container">
                    <article>
                        <h3>모델 1 (비정규화된 단일 테이블)</h3>
                        <ul>
                            <li>고객과 계좌 정보를 하나의 테이블에 통합</li>
                            <li>고객이 여러 계좌를 가질 경우 고객 정보가 중복 저장됨</li>
                            <li><strong>장점:</strong> 조회 성능 향상, 간단한 쿼리</li>
                            <li><strong>단점:</strong> 데이터 중복, 이상현상 발생 가능</li>
                        </ul>
                    </article>
                    <article>
                        <h3>모델 2 (정규화된 3개 테이블)</h3>
                        <ul>
                            <li>고객, 계좌, 고객-계좌 관계 테이블로 분리</li>
                            <li>다대다 관계를 명확히 표현</li>
                            <li><strong>장점:</strong> 데이터 중복 최소화, 무결성 보장</li>
                            <li><strong>단점:</strong> 조인 연산 필요, 복잡한 쿼리</li>
                        </ul>
                    </article>
                </div>

                <h3>데이터베이스 정규화의 핵심 개념</h3>
                <ul>
                    <li>데이터 중복 제거 및 저장 공간 최적화</li>
                    <li>삽입, 수정, 삭제 이상현상 방지</li>
                    <li>데이터 무결성 보장</li>
                    <li>데이터 구조의 안정성 향상</li>
                </ul>

                <h3>비정규화 고려사항</h3>
                <ul>
                    <li>조회 성능 향상이 주요 목적</li>
                    <li>의도적인 정규화 원칙 위배</li>
                    <li>데이터 정합성 유지를 위한 추가 작업 필요</li>
                </ul>
                <div class="image-container">
                    <img src="images/problem1.png" alt="데이터베이스 모델 비교">
                </div>
                <article class="summary-box">
                    <h4>쉬운 설명: 데이터 저장하는 두 가지 방법</h4>
                    <p><strong>방법 1 (하나의 큰 표):</strong> 한 번에 모든 정보를 볼 수 있어 편하지만, 같은 정보(예: 김철수)가 여러 번 반복해서 저장될 수 있어요.</p>
                    <p><strong>방법 2 (여러 개의 작은 표):</strong> 같은 정보는 한 번만 저장해서 깔끔하지만, 정보를 합쳐 보려면 여러 표를 연결해야 하는 번거로움이 있어요.</p>
                </article>
            </section>

            <section id="problem2" class="card">
                <h2>문제 2: 관계대수 연산</h2>
                <div class="image-container">
                    <img src="images/quiz2.png" alt="문제 2 이미지">
                </div>
                <p>두 릴레이션 R(A,B)와 S(B,C)에 대한 합집합, 차집합, 카티션 곱, 선택 연산의 결과를 구하는 문제입니다.</p>
                
                <h3>관계대수 연산 결과</h3>
                <ul>
                    <li>① R ∪ S (합집합): <strong>정의되지 않음</strong> (두 릴레이션이 동일한 속성을 가져야 함)</li>
                    <li>② R - S (차집합): <strong>정의되지 않음</strong> (합집합과 마찬가지로 스키마 호환성 필요)</li>
                    <li>③ R × S (카티션 곱): <strong>4개 튜플 생성</strong> (|R| × |S| = 2 × 2 = 4)</li>
                    <li>④ σ<sub>B='b1'</sub>(S): <strong>2개 튜플 선택</strong> (S의 모든 튜플이 조건을 만족)</li>
                </ul>

                <h3>관계대수의 기본 원리</h3>
                <div class="grid-container">
                    <article>
                        <h4>집합 연산자</h4>
                        <ul>
                            <li>합집합(∪), 교집합(∩), 차집합(-)</li>
                            <li>합병 가능한 릴레이션 필요 (속성 개수와 타입 동일, 도메인 호환)</li>
                        </ul>
                    </article>
                    <article>
                        <h4>순수 관계 연산자</h4>
                        <ul>
                            <li>선택(σ): 조건을 만족하는 튜플 선택</li>
                            <li>투영(π): 특정 속성만 추출</li>
                            <li>조인(⨝): 두 릴레이션을 연결</li>
                            <li>나눗셈(÷): 특정 조건을 모두 만족하는 튜플 반환</li>
                        </ul>
                    </article>
                </div>
                <div class="image-container">
                    <img src="images/problem2.png" alt="관계대수 연산">
                </div>
                <article class="summary-box">
                    <h4>쉬운 설명: 수학처럼 표를 계산하기</h4>
                    <p>두 개의 표 R(이름, 나이)과 S(나이, 취미)가 있을 때:</p>
                    <ul>
                        <li><strong>합치기/빼기 (∪, -):</strong> ❌ 불가능! (항목 종류가 달라서)</li>
                        <li><strong>모든 조합 만들기 (×):</strong> ✅ 가능! (모든 경우의 수를 조합)</li>
                        <li><strong>조건 찾기 (σ):</strong> ✅ 가능! (조건에 맞는 것만 골라내기)</li>
                    </ul>
                </article>
            </section>

            <section id="problem3" class="card">
                <h2>문제 3: SQL 질의 작성</h2>
                <div class="image-container">
                    <img src="images/quiz3.png" alt="문제 3 이미지">
                </div>
                <p>K회사의 부서-사원 데이터베이스에 대한 테이블 생성, 조회, 수정 등 SQL 문제 5개입니다.</p>

                <div class="sql-example">
                    <h3>(a) 테이블 생성 (DDL)</h3>
                    <p>DDL(Data Definition Language)은 테이블과 같은 데이터 구조를 정의하는 명령어입니다.</p>
                    <pre><code class="sql">-- Department 테이블(부서 정보 저장소) 만들기
CREATE TABLE Department (
    dept_no CHAR(4) PRIMARY KEY,     -- 부서 번호 (문자 4글자, 예: 'D001') / PRIMARY KEY: 중복 불가 + 비어있을 수 없음
    dept_name VARCHAR(20) NOT NULL,  -- 부서 이름 (최대 20글자) / NOT NULL: 반드시 값이 있어야 함
    budget INT NOT NULL              -- 부서 예산 (정수 숫자) / NOT NULL: 반드시 값이 있어야 함
);

-- Employee 테이블(직원 정보 저장소) 만들기
CREATE TABLE Employee (
    emp_no CHAR(4) PRIMARY KEY,          -- 사원 번호 (문자 4글자) / PRIMARY KEY: 중복 불가 + 비어있을 수 없음
    emp_name VARCHAR(20) NOT NULL,       -- 사원 이름 (최대 20글자) / NOT NULL: 반드시 값이 있어야 함
    dept_no CHAR(4) NOT NULL,            -- 부서 번호 (문자 4글자) / NOT NULL: 반드시 값이 있어야 함
    salary INT NOT NULL,                 -- 급여 (정수) / NOT NULL: 반드시 값이 있어야 함
    years INT NOT NULL,                  -- 근무 연수(몇 년 근무했는지) / NOT NULL
    FOREIGN KEY (dept_no) REFERENCES Department(dept_no)
        -- FOREIGN KEY: 다른 테이블(Department)의 dept_no를 참조 (연결)함
        -- 즉, Employee의 dept_no는 Department 테이블에 있는 부서 번호 중 하나여야 함
);</code></pre>
                </div>

                <div class="sql-example">
                    <h3>(b) 특정 사원의 부서명 조회</h3>
                    <p>사번 'E103'인 직원이 속한 부서의 이름을 조회합니다.</p>
                    <pre><code class="sql">SELECT d.dept_name                 -- d(Department 테이블)의 부서 이름만 선택
FROM Employee e                    -- Employee 테이블을 e라는 별명으로 사용
JOIN Department d                   -- Department 테이블을 d라는 별명으로 사용
    ON e.dept_no = d.dept_no         -- 두 테이블을 부서 번호(dept_no)로 연결
WHERE e.emp_no = 'E103';            -- e(Employee)의 사번(emp_no)이 'E103'인 경우만 찾음</code></pre>
                </div>

                <div class="sql-example">
                    <h3>(c) 부서별 평균 급여</h3>
                    <p>각 부서별로 직원들의 평균 급여를 계산합니다.</p>
                    <pre><code class="sql">SELECT d.dept_name,                  -- 부서 이름
       AVG(e.salary) AS avg_salary   -- 그 부서의 평균 급여 (AVG: 평균 함수) / AS avg_salary: 결과 칼럼 이름 붙이기
FROM Employee e
JOIN Department d
    ON e.dept_no = d.dept_no         -- 부서 번호로 두 테이블 연결
GROUP BY d.dept_name;                -- 부서 이름별로 묶어서(그룹별로) 평균을 계산</code></pre>
                </div>

                <div class="sql-example">
                    <h3>(a) 테이블 생성 (DDL)</h3>
                    <pre><code class="sql">/* ========================================================
(a) 테이블 생성 (DDL)
DDL: Data Definition Language → 테이블(데이터 저장소)을 만드는 명령어
======================================================== */
-- Department 테이블(부서 정보 저장소) 만들기
CREATE TABLE Department (
    dept_no CHAR(4) PRIMARY KEY,     -- 부서 번호 (문자 4글자, 예: 'D001') / PRIMARY KEY: 중복 불가 + 비어있을 수 없음
    dept_name VARCHAR(20) NOT NULL,  -- 부서 이름 (최대 20글자) / NOT NULL: 반드시 값이 있어야 함
    budget INT NOT NULL              -- 부서 예산 (정수 숫자) / NOT NULL: 반드시 값이 있어야 함
);

-- Employee 테이블(직원 정보 저장소) 만들기
CREATE TABLE Employee (
    emp_no CHAR(4) PRIMARY KEY,          -- 사원 번호 (문자 4글자) / PRIMARY KEY: 중복 불가 + 비어있을 수 없음
    emp_name VARCHAR(20) NOT NULL,       -- 사원 이름 (최대 20글자) / NOT NULL: 반드시 값이 있어야 함
    dept_no CHAR(4) NOT NULL,            -- 부서 번호 (문자 4글자) / NOT NULL: 반드시 값이 있어야 함
    salary INT NOT NULL,                 -- 급여 (정수) / NOT NULL: 반드시 값이 있어야 함
    years INT NOT NULL,                  -- 근무 연수(몇 년 근무했는지) / NOT NULL
    FOREIGN KEY (dept_no) REFERENCES Department(dept_no)
        -- FOREIGN KEY: 다른 테이블(Department)의 dept_no를 참조 (연결)함
        -- 즉, Employee의 dept_no는 Department 테이블에 있는 부서 번호 중 하나여야 함
);</code></pre>
                </div>

                <div class="sql-example">
                    <h3>(b) 특정 사원의 부서명 조회</h3>
                    <pre><code class="sql">/* ========================================================
(b) 특정 사원의 부서명 조회
사번이 'E103'인 사람이 속한 부서 이름을 찾는 SQL
======================================================== */
SELECT d.dept_name                 -- d(Department 테이블)의 부서 이름만 선택
FROM Employee e                    -- Employee 테이블을 e라는 별명으로 사용
JOIN Department d                   -- Department 테이블을 d라는 별명으로 사용
    ON e.dept_no = d.dept_no         -- 두 테이블을 부서 번호(dept_no)로 연결
WHERE e.emp_no = 'E103';            -- e(Employee)의 사번(emp_no)이 'E103'인 경우만 찾음</code></pre>
                </div>

                <div class="sql-example">
                    <h3>(c) 부서별 평균 급여</h3>
                    <pre><code class="sql">/* ========================================================
(c) 부서별 평균 급여
부서별로 급여 평균을 구하는 SQL
======================================================== */
SELECT d.dept_name,                  -- 부서 이름
       AVG(e.salary) AS avg_salary   -- 그 부서의 평균 급여 (AVG: 평균 함수) / AS avg_salary: 결과 칼럼 이름 붙이기
FROM Employee e
JOIN Department d
    ON e.dept_no = d.dept_no         -- 부서 번호로 두 테이블 연결
GROUP BY d.dept_name;                -- 부서 이름별로 묶어서(그룹별로) 평균을 계산</code></pre>
                </div>

                <div class="sql-example">
                    <h3>(d) 같은 부서 사원 조회 (SELF JOIN)</h3>
                    <pre><code class="sql">/* ========================================================
(d) 같은 부서 사원 조회 (SELF JOIN)
'백영란'과 같은 부서에 있는 직원들의 이름과 부서명을 찾는 SQL
SELF JOIN: 같은 테이블을 2번 불러서 서로 비교
======================================================== */
SELECT e2.emp_name, d.dept_name       -- e2(Employee)의 이름, 부서 이름
FROM Employee e1                      -- Employee 테이블을 e1이라는 별명으로 사용 (첫 번째 자기 자신)
JOIN Employee e2                      -- Employee 테이블을 e2라는 별명으로 사용 (두 번째 자기 자신)
    ON e1.dept_no = e2.dept_no         -- e1과 e2의 부서 번호가 같은 사람들만 연결
JOIN Department d
    ON e2.dept_no = d.dept_no          -- 부서 번호로 Department 테이블 연결
WHERE e1.emp_name = '백영란';          -- 첫 번째 직원(e1)의 이름이 '백영란'인 경우</code></pre>
                </div>

                <div class="sql-example">
                    <h3>(e) 근무년수 업데이트</h3>
                    <pre><code class="sql">/* ========================================================
(e) 근무년수 업데이트
모든 직원의 근무 연수를 1년씩 늘리고, 변경 결과 확인
======================================================== */
UPDATE Employee
SET years = years + 1;       -- years(현재 근무연수)에 1을 더함

SELECT * FROM Employee;      -- Employee 테이블의 모든 칼럼(*)을 다 보여줌</code></pre>
                </div>

                <article class="summary-box">
                    <h4>쉬운 설명: 컴퓨터에게 명령하기 (SQL)</h4>
                    <ul>
                        <li><strong>CREATE:</strong> 새로운 표 만들기</li>
                        <li><strong>SELECT:</strong> 정보 찾기</li>
                        <li><strong>JOIN:</strong> 여러 표 연결하기</li>
                        <li><strong>UPDATE:</strong> 정보 바꾸기</li>
                        <li><strong>GROUP BY:</strong> 비슷한 것끼리 묶기</li>
                    </ul>
                    <p><em>예시: "백영란과 같은 부서 사람 찾기" → 백영란의 부서를 먼저 찾고(SELECT), 그 부서에 속한 다른 사람들을 찾아요(JOIN).</em></p>
                </article>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025. Cline. All rights reserved.</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>
