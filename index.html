<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>데이터베이스 중간 예제 풀이</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>데이터베이스 중간 예제 풀이</h1>
            <nav>
                <ul>
                    <li><a href="#db-summary">DB 핵심 정리</a></li>
                    <li><a href="#problem1">문제 1: 모델 변환</a></li>
                    <li><a href="#problem2">문제 2: 관계대수</a></li>
                    <li><a href="#problem3">문제 3: SQL</a></li>
                    <li><a href="#sql-examples">SQL 예시</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <div class="container">
            <section id="db-summary" class="card">
                <h2>📄 데이터베이스 핵심 정리 (쉬운 버전)</h2>
                
                <h3>1. 데이터베이스 기본</h3>
                <p><strong>정의:</strong> 여러 사람이 함께 사용할 수 있도록 데이터를 체계적으로 모아둔 저장소<br>
                → 쉽게 말해, 컴퓨터 안에 있는 ‘정리된 데이터 창고’</p>
                
                <h4>특징</h4>
                <ul>
                    <li>여러 사람이 동시에 사용 가능</li>
                    <li>중복 데이터 줄임 → 데이터가 헷갈리지 않게 함</li>
                    <li>필요할 때 빠르게 검색·수정·삭제 가능</li>
                </ul>

                <h3>2. 데이터베이스 종류와 장단점</h3>
                <div class="table-responsive">
                    <table>
                        <thead>
                            <tr>
                                <th>종류</th>
                                <th>설명</th>
                                <th>장점</th>
                                <th>단점</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>계층형 DB</td>
                                <td>데이터가 <strong>트리(나무)</strong>처럼 층층이 연결됨. 부모-자식 관계가 확실함.<br>📌 예: 회사 조직도, 폴더 구조</td>
                                <td>- 구조가 단순해 이해 쉬움<br>- 데이터 찾는 속도가 빠름</td>
                                <td>- 구조를 바꾸기 어려움<br>- 새로운 데이터 연결이 불편</td>
                            </tr>
                            <tr>
                                <td>네트워크형 DB</td>
                                <td>데이터가 그물망처럼 서로 얽혀 연결됨.<br>📌 예: 항공편 노선도, SNS 친구 관계</td>
                                <td>- 복잡한 관계를 잘 표현 가능<br>- 여러 경로로 접근 가능</td>
                                <td>- 구조가 복잡함<br>- 설계·관리하기 어려움</td>
                            </tr>
                            <tr>
                                <td>관계형 DB</td>
                                <td>데이터를 <strong>표(테이블)</strong>로 저장하고 SQL로 관리.<br>📌 예: MySQL, Oracle, 학교 성적표</td>
                                <td>- 직관적이고 사용이 편리함<br>- 표준화 쉬움, 관리 용이</td>
                                <td>- 데이터가 매우 많아지면 속도가 느려질 수 있음<br>- 설계 과정 필요</td>
                            </tr>
                            <tr>
                                <td>객체지향형 DB</td>
                                <td>데이터를 객체 단위로 저장. 프로그램에서 쓰는 객체 개념과 같음.<br>📌 예: 3D 게임 데이터, 멀티미디어 DB</td>
                                <td>- 복잡한 데이터 구조를 쉽게 표현<br>- 프로그램과 호환성 높음</td>
                                <td>- 표준화 부족<br>- 배우고 구축하기 어려움</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>3. 데이터베이스 전체 장단점</h3>
                <div class="grid-container">
                    <article class="summary-box">
                        <h4>장점</h4>
                        <ul>
                            <li><strong>중복 감소:</strong> 같은 데이터를 여러 번 저장하지 않아 공간 절약</li>
                            <li><strong>일관성 유지:</strong> 틀린 데이터나 불일치 줄어듦</li>
                            <li><strong>보안 관리 가능:</strong> 접근 권한 설정 가능</li>
                            <li><strong>공유 용이:</strong> 여러 사용자가 동시에 사용 가능</li>
                            <li><strong>백업·복구 용이:</strong> 오류나 장애 시 빠른 복구 가능</li>
                        </ul>
                    </article>
                    <article class="summary-box">
                        <h4>단점</h4>
                        <ul>
                            <li><strong>비용이 많이 듦:</strong> 구축·운영에 돈과 시간 필요</li>
                            <li><strong>전문가 필요:</strong> 설계·관리 어려움</li>
                            <li><strong>장애 시 영향 큼:</strong> 서버가 멈추면 전체 사용 불가</li>
                        </ul>
                    </article>
                </div>
            </section>

            <section id="intro" class="card">
                <h2>데이터베이스 중간고사 문제 분석 및 정답 검토 보고서</h2>
                <p>제출된 데이터베이스 중간고사 문제는 데이터베이스 설계, 관계대수, SQL 등 핵심 개념을 다루는 3개의 문제로 구성되어 있습니다. 각 문제의 풀이를 상세히 분석하고 정답 여부를 검토한 결과, 모든 문제가 정답으로 판정되었으며, 데이터베이스의 주요 개념들이 정확하게 이해되고 적용되었음을 확인했습니다.</p>
            </section>

            <section id="problem1" class="card">
                <h2>문제 1: 데이터베이스 모델 변환: 비정규화 vs 정규화 모델 비교</h2>
                <div class="image-container">
                    <img src="images/quiz1.png" alt="문제 1 이미지">
                </div>
                <p>은행의 고객-계좌 데이터를 저장하는 모델을 비정규화된 단일 테이블과 정규화된 3개 테이블로 각각 변환하는 문제입니다.</p>
                
                <div class="grid-container">
                    <article>
                        <h3>모델 1 (비정규화된 단일 테이블)</h3>
                        <ul>
                            <li>고객과 계좌 정보를 하나의 테이블에 통합</li>
                            <li>고객이 여러 계좌를 가질 경우 고객 정보가 중복 저장됨</li>
                            <li><strong>장점:</strong> 조회 성능 향상, 간단한 쿼리</li>
                            <li><strong>단점:</strong> 데이터 중복, 이상현상 발생 가능</li>
                        </ul>
                    </article>
                    <article>
                        <h3>모델 2 (정규화된 3개 테이블)</h3>
                        <ul>
                            <li>고객, 계좌, 고객-계좌 관계 테이블로 분리</li>
                            <li>다대다 관계를 명확히 표현</li>
                            <li><strong>장점:</strong> 데이터 중복 최소화, 무결성 보장</li>
                            <li><strong>단점:</strong> 조인 연산 필요, 복잡한 쿼리</li>
                        </ul>
                    </article>
                </div>

                <h3>정규화와 비정규화, 쉽게 알아보기</h3>
                <p>데이터를 표에 저장하는 방식에는 크게 '정리정돈'을 우선하는 <strong>정규화</strong>와 '속도'를 우선하는 <strong>비정규화</strong>가 있습니다.</p>
                <div class="grid-container">
                    <article>
                        <h4>정규화 (깔끔하게 정리하기)</h4>
                        <p>데이터를 주제에 맞게 여러 표로 잘게 나누어 저장하는 방법입니다. 이렇게 하면 다음과 같은 장점이 있어요.</p>
                        <ul>
                            <li><strong>데이터 중복 최소화:</strong> 같은 정보가 여러 번 저장되는 것을 막아줘요.</li>
                            <li><strong>이상 현상 방지:</strong> 데이터가 중복되어 생기는 수정/삭제/추가의 어려움을 해결해요.</li>
                            <li><strong>데이터 무결성 향상:</strong> 데이터가 항상 정확하고 일관된 상태, 즉 '믿을 수 있는 데이터'가 되도록 도와줘요.</li>
                        </ul>
                    </article>
                    <article>
                        <h4>비정규화 (빠르게 찾아보기)</h4>
                        <p>정리된 표를 일부러 합쳐서 중복을 허용하는 방법입니다. 데이터를 찾을 때 여러 표를 볼 필요가 없어서 속도가 빨라져요.</p>
                        <ul>
                            <li><strong>조회 성능 향상:</strong> 여러 표를 합치는 '조인' 연산이 줄어들어 검색이 빨라져요.</li>
                            <li><strong>단순한 쿼리:</strong> 데이터를 찾는 명령어가 더 간단해져요.</li>
                            <li><strong>주의점:</strong> 데이터가 중복되므로, 정보를 바꿀 때 모든 중복 데이터를 함께 바꿔주는 추가 작업이 필요해요.</li>
                        </ul>
                    </article>
                </div>
                <div class="image-container">
                    <img src="images/problem1.png" alt="데이터베이스 모델 비교">
                </div>
                <article class="summary-box">
                    <h4>쉬운 설명: 데이터 저장하는 두 가지 방법</h4>
                    <p><strong>방법 1 (하나의 큰 표):</strong> 한 번에 모든 정보를 볼 수 있어 편하지만, 같은 정보(예: 김철수)가 여러 번 반복해서 저장될 수 있어요.</p>
                    <p><strong>방법 2 (여러 개의 작은 표):</strong> 같은 정보는 한 번만 저장해서 깔끔하지만, 정보를 합쳐 보려면 여러 표를 연결해야 하는 번거로움이 있어요.</p>
                </article>
            </section>

            <section id="problem2" class="card">
                <h2>문제 2: 관계대수 연산</h2>
                <div class="image-container">
                    <img src="images/quiz2.png" alt="문제 2 이미지">
                </div>
                <p>두 릴레이션 R(A,B)와 S(B,C)에 대한 합집합, 차집합, 카티션 곱, 선택 연산의 결과를 구하는 문제입니다.</p>
                
                <h3>관계대수 연산 결과 (쉬운 풀이)</h3>
                <ul>
                    <li>
                        <strong>① R ∪ S (합집합):</strong> <strong>정의되지 않음</strong><br>
                        <small><strong>이유:</strong> 합집합은 두 표의 구조(열의 개수와 종류)가 똑같을 때만 가능해요. 문제의 두 표 R(A,B)과 S(B,C)는 구조가 달라서 합칠 수 없어요.</small>
                    </li>
                    <li>
                        <strong>② R - S (차집합):</strong> <strong>정의되지 않음</strong><br>
                        <small><strong>이유:</strong> 차집합도 합집합처럼 두 표의 구조가 같아야만 계산할 수 있어요.</small>
                    </li>
                    <li>
                        <strong>③ R × S (카티션 곱):</strong> <strong>4개의 줄(튜플) 생성</strong><br>
                        <small><strong>이유:</strong> 카티션 곱은 한쪽 표의 모든 줄을 다른 쪽 표의 모든 줄과 하나씩 짝짓는 연산이에요. R표에 2줄, S표에 2줄이 있으니 총 2 x 2 = 4개의 조합이 만들어져요.</small>
                    </li>
                    <li>
                        <strong>④ σ<sub>B='b1'</sub>(S):</strong> <strong>2개의 줄(튜플) 선택</strong><br>
                        <small><strong>이유:</strong> '선택(σ)' 연산은 조건에 맞는 줄만 골라내는 거예요. S표에서 'B열의 값이 b1인' 줄을 찾으면, 두 줄 모두 해당되므로 2개가 선택돼요.</small>
                    </li>
                </ul>

                <h3>관계대수 용어, 쉽게 이해하기</h3>
                <p>관계대수는 데이터베이스의 데이터를 '어떻게 다룰지'에 대한 수학적인 방법입니다. 어려운 기호들이 많지만, 알고 보면 간단한 개념들입니다.</p>
                
                <article class="summary-box">
                    <h4>기본 용어 정리</h4>
                    <ul>
                        <li><strong>릴레이션 (Relation):</strong> 그냥 '표(Table)'라고 생각하면 쉬워요.</li>
                        <li><strong>튜플 (Tuple):</strong> 표의 '가로 한 줄' 데이터입니다. (예: 한 학생의 정보)</li>
                        <li><strong>속성 (Attribute):</strong> 표의 '세로 한 줄', 즉 '열(Column)'입니다. (예: 이름, 학번, 학과)</li>
                        <li><strong>스키마 (Schema):</strong> 표의 '구조'나 '설계도'입니다. 어떤 속성들로 이루어져 있는지 나타내죠.</li>
                    </ul>
                </article>

                <h4>주요 연산자 풀이 (릴레이션 예시)</h4>
                <p>가상의 '1반 학생' 테이블과 '2반 학생', '동아리' 테이블을 예시로 각 연산자가 어떻게 동작하는지 알아봅시다.</p>

                <!-- 예시 테이블 -->
                <div class="grid-container table-examples">
                    <div class="table-example">
                        <h5>1반_학생 (Class1)</h5>
                        <table><thead><tr><th>이름</th><th>도시</th></tr></thead><tbody><tr><td>김민준</td><td>서울</td></tr><tr><td>이서연</td><td>부산</td></tr></tbody></table>
                    </div>
                    <div class="table-example">
                        <h5>2반_학생 (Class2)</h5>
                        <table><thead><tr><th>이름</th><th>도시</th></tr></thead><tbody><tr><td>박하준</td><td>서울</td></tr><tr><td>이서연</td><td>부산</td></tr></tbody></table>
                    </div>
                    <div class="table-example">
                        <h5>동아리 (Club)</h5>
                        <table><thead><tr><th>이름</th><th>동아리</th></tr></thead><tbody><tr><td>김민준</td><td>농구반</td></tr><tr><td>박하준</td><td>축구반</td></tr></tbody></table>
                    </div>
                </div>

                <div class="operator-examples">
                    <article>
                        <h5><strong>합집합 (∪):</strong> Class1 ∪ Class2</h5>
                        <p>두 테이블의 모든 데이터를 합칩니다. (중복은 한 번만 표시)</p>
                        <table><thead><tr><th>이름</th><th>도시</th></tr></thead><tbody><tr><td>김민준</td><td>서울</td></tr><tr><td>이서연</td><td>부산</td></tr><tr><td>박하준</td><td>서울</td></tr></tbody></table>
                    </article>
                    <article>
                        <h5><strong>차집합 (-):</strong> Class1 - Class2</h5>
                        <p>첫 번째 테이블(Class1)에서 두 번째 테이블(Class2)과 겹치는 데이터를 제외합니다.</p>
                        <table><thead><tr><th>이름</th><th>도시</th></tr></thead><tbody><tr><td>김민준</td><td>서울</td></tr></tbody></table>
                    </article>
                    <article>
                        <h5><strong>카티션 곱 (×):</strong> Class1 × Club</h5>
                        <p>두 테이블의 모든 행을 1:1로 조합하여 가능한 모든 경우의 수를 만듭니다.</p>
                        <table><thead><tr><th>Class1.이름</th><th>도시</th><th>Club.이름</th><th>동아리</th></tr></thead><tbody><tr><td>김민준</td><td>서울</td><td>김민준</td><td>농구반</td></tr><tr><td>김민준</td><td>서울</td><td>박하준</td><td>축구반</td></tr><tr><td>이서연</td><td>부산</td><td>김민준</td><td>농구반</td></tr><tr><td>이서연</td><td>부산</td><td>박하준</td><td>축구반</td></tr></tbody></table>
                    </article>
                    <article>
                        <h5><strong>선택 (σ):</strong> σ <sub>도시='서울'</sub> (Class1)</h5>
                        <p>테이블에서 특정 조건(예: 도시가 '서울')을 만족하는 행 전체를 선택합니다.</p>
                        <table><thead><tr><th>이름</th><th>도시</th></tr></thead><tbody><tr><td>김민준</td><td>서울</td></tr></tbody></table>
                    </article>
                    <article>
                        <h5><strong>투영 (π):</strong> π <sub>이름</sub> (Class1)</h5>
                        <p>테이블에서 원하는 특정 열(예: '이름')만 추출합니다.</p>
                        <table><thead><tr><th>이름</th></tr></thead><tbody><tr><td>김민준</td></tr><tr><td>이서연</td></tr></tbody></table>
                    </article>
                    <article>
                        <h5><strong>조인 (⨝):</strong> Class1 ⨝ Club</h5>
                        <p>두 테이블에서 공통된 속성('이름')을 기준으로 데이터를 합쳐 새로운 정보를 만듭니다.</p>
                        <table><thead><tr><th>이름</th><th>도시</th><th>동아리</th></tr></thead><tbody><tr><td>김민준</td><td>서울</td><td>농구반</td></tr></tbody></table>
                    </article>
                </div>
                <div class="image-container">
                    <img src="images/problem2.png" alt="관계대수 연산">
                </div>
            </section>

            <section id="problem3" class="card">
                <h2>문제 3: SQL 질의 작성</h2>
                <div class="image-container">
                    <img src="images/quiz3.png" alt="문제 3 이미지">
                </div>
                <p>K회사의 부서-사원 데이터베이스에 대한 테이블 생성, 조회, 수정 등 SQL 문제 5개입니다.</p>

                <div class="sql-example">
                    <h3>(a) 테이블 생성 (DDL)</h3>
                    <pre><code class="sql">/* ========================================================
(a) 테이블 생성 (DDL)
DDL: Data Definition Language → 테이블(데이터 저장소)을 만드는 명령어
======================================================== */
-- Department 테이블(부서 정보 저장소) 만들기
CREATE TABLE Department (
    dept_no CHAR(4) PRIMARY KEY,     -- 부서 번호 (문자 4글자, 예: 'D001') / PRIMARY KEY: 중복 불가 + 비어있을 수 없음
    dept_name VARCHAR(20) NOT NULL,  -- 부서 이름 (최대 20글자) / NOT NULL: 반드시 값이 있어야 함
    budget INT NOT NULL              -- 부서 예산 (정수 숫자) / NOT NULL: 반드시 값이 있어야 함
);

-- Employee 테이블(직원 정보 저장소) 만들기
CREATE TABLE Employee (
    emp_no CHAR(4) PRIMARY KEY,          -- 사원 번호 (문자 4글자) / PRIMARY KEY: 중복 불가 + 비어있을 수 없음
    emp_name VARCHAR(20) NOT NULL,       -- 사원 이름 (최대 20글자) / NOT NULL: 반드시 값이 있어야 함
    dept_no CHAR(4) NOT NULL,            -- 부서 번호 (문자 4글자) / NOT NULL: 반드시 값이 있어야 함
    salary INT NOT NULL,                 -- 급여 (정수) / NOT NULL: 반드시 값이 있어야 함
    years INT NOT NULL,                  -- 근무 연수(몇 년 근무했는지) / NOT NULL
    FOREIGN KEY (dept_no) REFERENCES Department(dept_no)
        -- FOREIGN KEY: 다른 테이블(Department)의 dept_no를 참조 (연결)함
        -- 즉, Employee의 dept_no는 Department 테이블에 있는 부서 번호 중 하나여야 함
);</code></pre>
                    <article class="summary-box">
                        <h4>쉬운 용어 풀이 (a)</h4>
                        <ul>
                            <li><strong>CREATE TABLE:</strong> '표 만들기' 라는 뜻이에요. 데이터를 저장할 공간을 만듭니다.</li>
                            <li><strong>PRIMARY KEY:</strong> '기본 열쇠'처럼 각 줄을 구별하는 고유한 값입니다. (예: 학번, 주민등록번호)</li>
                            <li><strong>NOT NULL:</strong> '비워두면 안 됨' 이라는 규칙으로, 필수 입력 항목을 의미합니다.</li>
                            <li><strong>FOREIGN KEY:</strong> 다른 표와 연결하는 '연결고리' 역할입니다. (예: 직원 정보에 부서 번호를 연결)</li>
                        </ul>
                    </article>
                </div>

                <div class="sql-example">
                    <h3>(b) 특정 사원의 부서명 조회</h3>
                    <pre><code class="sql">/* ========================================================
(b) 특정 사원의 부서명 조회
사번이 'E103'인 사람이 속한 부서 이름을 찾는 SQL
======================================================== */
SELECT d.dept_name                 -- d(Department 테이블)의 부서 이름만 선택
FROM Employee e                    -- Employee 테이블을 e라는 별명으로 사용
JOIN Department d                   -- Department 테이블을 d라는 별명으로 사용
    ON e.dept_no = d.dept_no         -- 두 테이블을 부서 번호(dept_no)로 연결
WHERE e.emp_no = 'E103';            -- e(Employee)의 사번(emp_no)이 'E103'인 경우만 찾음</code></pre>
                    <article class="summary-box">
                        <h4>쉬운 용어 풀이 (b)</h4>
                        <ul>
                            <li><strong>SELECT:</strong> '선택하기' 라는 뜻으로, 보고 싶은 정보(열)를 고릅니다.</li>
                            <li><strong>FROM:</strong> '...에서 가져오기' 라는 뜻으로, 어떤 표에서 데이터를 가져올지 지정합니다.</li>
                            <li><strong>JOIN...ON:</strong> 두 개의 표를 특정 조건(ON)에 맞춰 합치는 기능입니다.</li>
                            <li><strong>WHERE:</strong> '...인 경우만' 이라는 뜻으로, 원하는 조건에 맞는 데이터만 골라냅니다.</li>
                        </ul>
                    </article>
                </div>

                <div class="sql-example">
                    <h3>(c) 부서별 평균 급여</h3>
                    <pre><code class="sql">/* ========================================================
(c) 부서별 평균 급여
부서별로 급여 평균을 구하는 SQL
======================================================== */
SELECT d.dept_name,                  -- 부서 이름
       AVG(e.salary) AS avg_salary   -- 그 부서의 평균 급여 (AVG: 평균 함수) / AS avg_salary: 결과 칼럼 이름 붙이기
FROM Employee e
JOIN Department d
    ON e.dept_no = d.dept_no         -- 부서 번호로 두 테이블 연결
GROUP BY d.dept_name;                -- 부서 이름별로 묶어서(그룹별로) 평균을 계산</code></pre>
                    <article class="summary-box">
                        <h4>쉬운 용어 풀이 (c)</h4>
                        <ul>
                            <li><strong>AVG(...):</strong> '평균'을 계산하는 함수입니다.</li>
                            <li><strong>AS:</strong> '...라는 이름으로' 라는 뜻으로, 결과 표의 열 이름을 보기 좋게 바꿔줍니다.</li>
                            <li><strong>GROUP BY:</strong> '그룹으로 묶기' 라는 뜻으로, 특정 항목(예: 부서)별로 데이터를 묶어 계산할 때 사용합니다.</li>
                        </ul>
                    </article>
                </div>

                <div class="sql-example">
                    <h3>(d) 같은 부서 사원 조회 (SELF JOIN)</h3>
                    <pre><code class="sql">/* ========================================================
(d) 같은 부서 사원 조회 (SELF JOIN)
'백영란'과 같은 부서에 있는 직원들의 이름과 부서명을 찾는 SQL
SELF JOIN: 같은 테이블을 2번 불러서 서로 비교
======================================================== */
SELECT e2.emp_name, d.dept_name       -- e2(Employee)의 이름, 부서 이름
FROM Employee e1                      -- Employee 테이블을 e1이라는 별명으로 사용 (첫 번째 자기 자신)
JOIN Employee e2                      -- Employee 테이블을 e2라는 별명으로 사용 (두 번째 자기 자신)
    ON e1.dept_no = e2.dept_no         -- e1과 e2의 부서 번호가 같은 사람들만 연결
JOIN Department d
    ON e2.dept_no = d.dept_no          -- 부서 번호로 Department 테이블 연결
WHERE e1.emp_name = '백영란';          -- 첫 번째 직원(e1)의 이름이 '백영란'인 경우</code></pre>
                    <article class="summary-box">
                        <h4>쉬운 용어 풀이 (d)</h4>
                        <ul>
                            <li><strong>SELF JOIN:</strong> '자기 자신과 합치기' 라는 뜻으로, 하나의 표를 두 개인 것처럼 사용하여 내부 데이터를 비교할 때 씁니다.</li>
                        </ul>
                    </article>
                </div>

                <div class="sql-example">
                    <h3>(e) 근무년수 업데이트</h3>
                    <pre><code class="sql">/* ========================================================
(e) 근무년수 업데이트
모든 직원의 근무 연수를 1년씩 늘리고, 변경 결과 확인
======================================================== */
UPDATE Employee
SET years = years + 1;       -- years(현재 근무연수)에 1을 더함

SELECT * FROM Employee;      -- Employee 테이블의 모든 칼럼(*)을 다 보여줌</code></pre>
                    <article class="summary-box">
                        <h4>쉬운 용어 풀이 (e)</h4>
                        <ul>
                            <li><strong>UPDATE:</strong> '수정하기' 라는 뜻으로, 표의 기존 데이터를 바꿀 때 사용합니다.</li>
                            <li><strong>SET:</strong> '...으로 맞추기' 라는 뜻으로, 어떤 값을 어떻게 바꿀지 지정합니다.</li>
                            <li><strong>SELECT *:</strong> '*'는 '모든 것'을 의미하며, 표의 모든 열을 보여달라는 뜻입니다.</li>
                        </ul>
                    </article>
                </div>

                <h3>SQL 핵심 개념 정리</h3>
                <div class="grid-container">
                    <article>
                        <h4>DDL (Data Definition Language)</h4>
                        <ul>
                            <li><strong>CREATE:</strong> 테이블, 인덱스 등 객체 생성</li>
                            <li><strong>ALTER:</strong> 기존 객체 구조 변경</li>
                            <li><strong>DROP:</strong> 객체 삭제</li>
                        </ul>
                    </article>
                    <article>
                        <h4>DML (Data Manipulation Language)</h4>
                        <ul>
                            <li><strong>SELECT:</strong> 데이터 조회</li>
                            <li><strong>INSERT:</strong> 데이터 삽입</li>
                            <li><strong>UPDATE:</strong> 데이터 수정</li>
                            <li><strong>DELETE:</strong> 데이터 삭제</li>
                        </ul>
                    </article>
                </div>
                <div class="sql-concepts">
                    <h4>JOIN 연산의 종류</h4>
                    <ul>
                        <li><strong>INNER JOIN:</strong> 조건을 만족하는 교집합</li>
                        <li><strong>LEFT/RIGHT JOIN:</strong> 한쪽 테이블 기준으로 결합</li>
                        <li><strong>FULL OUTER JOIN:</strong> 모든 데이터 포함</li>
                        <li><strong>SELF JOIN:</strong> 같은 테이블을 자기 자신과 결합</li>
                    </ul>
                </div>

                <article class="summary-box">
                    <h4>쉬운 설명: 컴퓨터에게 SQL로 명령하기</h4>
                    <p>SQL은 '데이터베이스 전용 언어'입니다. 우리가 사람에게 말하듯, 컴퓨터의 데이터베이스에게 "이런 데이터 좀 찾아줘" 또는 "이 정보 좀 저장해줘" 라고 명령할 때 사용하는 특별한 언어입니다. SELECT, FROM, WHERE 같은 영어 단어를 조합해서 사용하죠.</p>
                </article>
            </section>

            <section id="sql-examples" class="card">
                <h3>SQL 예시: 초보자를 위한 상황별 코드</h3>
                <p>가장 일반적으로 사용되는 '학생(Students)' 테이블을 예시로 SQL 명령어를 종류별로 알아봅시다.</p>

                <!-- DDL 예시 -->
                <h4 class="sql-category">1. 데이터 정의어 (DDL): 테이블 구조 만들기</h4>
                <p>DDL은 데이터를 담을 '표(테이블)'의 구조를 만들거나(CREATE), 바꾸거나(ALTER), 삭제(DROP)할 때 사용합니다.</p>
                <div class="sql-example">
                    <h5>(1) CREATE: 학생 정보 테이블 만들기</h5>
                    <pre><code class="sql">/*
학생 정보를 저장할 'Students'라는 이름의 표를 만듭니다.
어떤 정보를 저장할지 각 열(Column)의 이름과 데이터 타입을 정해줍니다.
*/
CREATE TABLE Students (
    student_id INT PRIMARY KEY,  -- 학생 ID (숫자, 중복 불가, 각 학생을 구별하는 고유값)
    name VARCHAR(50) NOT NULL,   -- 이름 (최대 50글자, 비워둘 수 없음)
    major VARCHAR(50),           -- 전공 (최대 50글자, 비워둬도 됨)
    grade INT,                   -- 학년 (숫자)
    birth_date DATE              -- 생년월일 (날짜 형식, 예: '2005-03-15')
);</code></pre>
                    <article class="summary-box">
                        <h6>용어 팁</h6>
                        <ul>
                            <li><strong>INT:</strong> 정수(Integer) 숫자를 의미해요. (예: 1, 100, -5)</li>
                            <li><strong>VARCHAR(n):</strong> 최대 n글자까지 들어가는 문자열(Variable Character)을 의미해요.</li>
                            <li><strong>DATE:</strong> 날짜 데이터를 의미해요.</li>
                            <li><strong>PRIMARY KEY:</strong> 이 열은 절대로 중복된 값을 가질 수 없으며, 각 데이터를 식별하는 기준이 됩니다.</li>
                            <li><strong>NOT NULL:</strong> 이 열은 비워둘 수 없다는 뜻입니다. 반드시 값을 넣어야 해요.</li>
                        </ul>
                    </article>
                </div>
                <div class="sql-example">
                    <h5>(2) ALTER: 테이블 구조 변경하기</h5>
                    <pre><code class="sql">/*
이미 만들어진 'Students' 테이블에 'email'이라는 새로운 열을 추가합니다.
*/
-- 이메일(email) 열 추가하기
ALTER TABLE Students
ADD email VARCHAR(100); -- 최대 100글자의 이메일 주소를 저장할 공간 추가

/*
'grade' 열의 이름을 'student_grade'로 변경해봅시다. (데이터베이스 종류에 따라 문법이 다를 수 있음)
*/
-- 열 이름 변경하기 (MySQL 예시)
ALTER TABLE Students
RENAME COLUMN grade TO student_grade;</code></pre>
                </div>
                <div class="sql-example">
                    <h5>(3) DROP: 테이블 삭제하기</h5>
                    <pre><code class="sql">/*
'Students' 테이블이 더 이상 필요 없을 때, 테이블과 안의 모든 데이터를 완전히 삭제합니다.
(주의! 실행하면 복구하기 매우 어렵습니다.)
*/
DROP TABLE Students;</code></pre>
                </div>

                <!-- DML 예시 -->
                <h4 class="sql-category">2. 데이터 조작어 (DML): 데이터 다루기</h4>
                <p>DML은 테이블에 실제 데이터를 넣거나(INSERT), 찾아보거나(SELECT), 바꾸거나(UPDATE), 지울 때(DELETE) 사용합니다.</p>
                <div class="sql-example">
                    <h5>(1) INSERT: 새로운 데이터 추가하기</h5>
                    <pre><code class="sql">/*
'Students' 테이블에 새로운 학생 3명의 정보를 추가합니다.
*/
INSERT INTO Students (student_id, name, major, student_grade, birth_date, email)
VALUES (2024001, '김민준', '컴퓨터공학', 2, '2004-05-10', 'mj.kim@example.com');

INSERT INTO Students (student_id, name, major, student_grade, birth_date, email)
VALUES (2024002, '이서연', '경영학', 1, '2005-11-22', 'sy.lee@example.com');

INSERT INTO Students (student_id, name, major, student_grade) -- 생일, 이메일 정보는 빼고 추가
VALUES (2024003, '박하은', '디자인', 4);</code></pre>
                </div>
                <div class="sql-example">
                    <h5>(2) SELECT: 데이터 조회하기</h5>
                    <pre><code class="sql">/*
'Students' 테이블에서 원하는 정보를 찾아봅니다. 가장 많이 사용하는 명령어입니다.
*/
-- 모든 학생의 모든 정보 보기
SELECT * FROM Students;

-- 학생들의 '이름'과 '전공' 정보만 보기
SELECT name, major FROM Students;

-- '컴퓨터공학' 전공인 학생만 찾기
SELECT * FROM Students
WHERE major = '컴퓨터공학';

-- 2학년 이상인 학생들의 이름과 학년 보기
SELECT name, student_grade FROM Students
WHERE student_grade >= 2;

-- 학생들을 이름 순서(가나다순)로 정렬해서 보기
SELECT * FROM Students
ORDER BY name ASC; -- ASC: 오름차순 (생략 가능), DESC: 내림차순</code></pre>
                </div>
                <div class="sql-example">
                    <h5>(3) UPDATE: 데이터 수정하기</h5>
                    <pre><code class="sql">/*
'Students' 테이블에 저장된 정보를 변경합니다.
*/
-- 학생 ID가 2024003인 학생의 전공을 '시각디자인'으로 변경
UPDATE Students
SET major = '시각디자인'
WHERE student_id = 2024003;

-- 모든 2학년 학생들의 학년을 3학년으로 올리기 (주의: WHERE를 안 쓰면 모든 데이터가 바뀜!)
UPDATE Students
SET student_grade = 3
WHERE student_grade = 2;</code></pre>
                </div>
                <div class="sql-example">
                    <h5>(4) DELETE: 데이터 삭제하기</h5>
                    <pre><code class="sql">/*
'Students' 테이블에서 특정 데이터를 삭제합니다.
*/
-- 학생 ID가 2024001인 학생의 정보를 삭제
DELETE FROM Students
WHERE student_id = 2024001;</code></pre>
                </div>

                <h4 class="sql-category">3. 고급 조회: 여러 테이블 정보 합치고 분석하기</h4>
                <p>실제 데이터베이스는 여러 테이블로 구성되어 있습니다. 이 테이블들을 연결(JOIN)하고 그룹으로 묶어(GROUP BY) 의미있는 정보를 뽑아낼 수 있습니다.</p>
                <div class="sql-example">
                    <h5>(1) JOIN: 테이블 연결하기</h5>
                    <p>학생들이 어떤 과목을 수강하는지 알려주는 'Enrollments' 테이블이 있다고 가정해봅시다.</p>
                    <pre><code class="sql">/*
-- 수강 정보 테이블 (가상)
CREATE TABLE Enrollments (
    enrollment_id INT PRIMARY KEY,
    student_id INT, -- 어떤 학생이
    course_name VARCHAR(50) -- 어떤 과목을 듣는지
);
*/

-- 학생 이름과 그 학생이 수강하는 과목 이름을 함께 보고 싶을 때
SELECT s.name, e.course_name
FROM Students s
JOIN Enrollments e ON s.student_id = e.student_id; -- 두 테이블의 학생 ID가 같은 것끼리 연결
</code></pre>
                </div>
                <div class="sql-example">
                    <h5>(2) GROUP BY & HAVING: 그룹별로 분석하기</h5>
                    <pre><code class="sql">/*
전공별로 학생이 몇 명이나 있는지 세어봅니다.
*/
SELECT major, COUNT(*) AS student_count -- COUNT(*): 모든 줄의 개수를 셈
FROM Students
GROUP BY major; -- 전공이 같은 학생들끼리 그룹으로 묶음

/*
학생 수가 10명 이상인 전공만 보고 싶을 때
*/
SELECT major, COUNT(*) AS student_count
FROM Students
GROUP BY major
HAVING COUNT(*) >= 10; -- GROUP BY로 묶인 결과에 조건을 걸 때 사용
</code></pre>
                </div>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025. Cline. All rights reserved.</p>
        </div>
    </footer>

    <script src="js/main.js"></script>
</body>
</html>
